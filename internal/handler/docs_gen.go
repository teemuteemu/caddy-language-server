// Code generated by cmd/docgen. DO NOT EDIT.

package handler

// directiveDocs maps Caddyfile directive names to Markdown documentation
// extracted from Caddy's source code.
var directiveDocs = map[string]string{
	"acme_server": "```\nacme_server [<matcher>] {\n\tca        <id>\n\tlifetime  <duration>\n\tresolvers <addresses...>\n\tchallenges <challenges...>\n\tallow_wildcard_names\n\tallow {\n\t\tdomains <domains...>\n\t\tip_ranges <addresses...>\n\t}\n\tdeny {\n\t\tdomains <domains...>\n\t\tip_ranges <addresses...>\n\t}\n\tsign_with_root\n}\n```",
	"append": "```\nappend {\n    wrap <another encoder>\n    fields {\n        <field> <value>\n    }\n    <field> <value>\n}\n```",
	"basic_auth": "```\nbasic_auth [<matcher>] [<hash_algorithm> [<realm>]] {\n    <username> <hashed_password>\n    ...\n}\n\n```\nIf no hash algorithm is supplied, bcrypt will be assumed.",
	"basicauth": "```\nbasic_auth [<matcher>] [<hash_algorithm> [<realm>]] {\n    <username> <hashed_password>\n    ...\n}\n\n```\nIf no hash algorithm is supplied, bcrypt will be assumed.",
	"bind": "```\n\tbind <addresses...> [{\n   protocols [h1|h2|h2c|h3] [...]\n }]\n```",
	"ca": "```\n... internal {\n    ca       <name>\n    lifetime <duration>\n    sign_with_root\n}\n```",
	"cert_selection": "```\ncert_selection {\n\tall_tags             <values...>\n\tany_tag              <values...>\n\tpublic_key_algorithm <dsa|ecdsa|rsa>\n\tserial_number        <big_integers...>\n\tsubject_organization <values...>\n}\n```",
	"client_auth": "```\nclient_auth {\n\tmode                   [request|require|verify_if_given|require_and_verify]\n \ttrust_pool\t\t\t   <module> {\n\t\t...\n\t}\n\tverifier               <module>\n}\n\n```\nIf `mode` is not provided, it defaults to `require_and_verify` if `trust_pool` is provided.\nOtherwise, it defaults to `require`.",
	"connection_policy": "```\nconnection_policy {\n\talpn                  <values...>\n\tcert_selection {\n\t\t...\n\t}\n\tciphers               <cipher_suites...>\n\tclient_auth {\n\t\t...\n\t}\n\tcurves                <curves...>\n\tdefault_sni           <server_name>\n\tmatch {\n\t\t...\n\t}\n\tprotocols             <min> [<max>]\n\t# EXPERIMENTAL:\n\tdrop\n\tfallback_sni          <server_name>\n\tinsecure_secrets_log  <log_file>\n}\n```",
	"console": "```\nconsole {\n    <common encoder config subdirectives...>\n}\n\n```\nSee the godoc on the LogEncoderConfig type for the syntax of\nsubdirectives that are common to most/all encoders.",
	"copy_response": "```\ncopy_response [<matcher>] [<status>] {\n    status <status>\n}\n```",
	"copy_response_headers": "```\ncopy_response_headers [<matcher>] {\n    include <fields...>\n    exclude <fields...>\n}\n```",
	"dir": "```\n... acme [<directory_url>] {\n    dir <directory_url>\n    test_dir <test_directory_url>\n    email <email>\n    profile <profile_name>\n    timeout <duration>\n    disable_http_challenge\n    disable_tlsalpn_challenge\n    alt_http_port    <port>\n    alt_tlsalpn_port <port>\n    eab <key_id> <mac_key>\n    trusted_roots <pem_files...>\n    dns <provider_name> [<options>]\n    propagation_delay <duration>\n    propagation_timeout <duration>\n    resolvers <dns_servers...>\n    dns_ttl <duration>\n    dns_challenge_override_domain <domain>\n    preferred_chains [smallest] {\n        root_common_name <common_names...>\n        any_common_name  <common_names...>\n    }\n}\n```",
	"dynamic": "```\ndynamic srv [<name>] {\n    service             <service>\n    proto               <proto>\n    name                <name>\n    refresh             <interval>\n    resolvers           <resolvers...>\n    dial_timeout        <timeout>\n    dial_fallback_delay <timeout>\n    grace_period        <duration>\n}\n```",
	"encode": "```\nencode [<matcher>] <formats...> {\n    gzip           [<level>]\n    zstd\n    minimum_length <length>\n    # response matcher block\n    match {\n        status <code...>\n        header <field> [<value>]\n    }\n    # or response matcher single line syntax\n    match [header <field> [<value>]] | [status <code...>]\n}\n\n```\nSpecifying the formats on the first line will use those formats' defaults.",
	"error": "```\nerror [<matcher>] <status>|<message> [<status>] {\n    message <text>\n}\n\n```\nIf there is just one argument (other than the matcher), it is considered\nto be a status code if it's a valid positive integer of 3 digits.",
	"file": "```\nfile <files...> {\n    root      <path>\n    try_files <files...>\n    try_policy first_exist|smallest_size|largest_size|most_recently_modified\n}\n```",
	"file_server": "```\nfile_server [<matcher>] [browse] {\n    fs            <filesystem>\n    root          <path>\n    hide          <files...>\n    index         <files...>\n    browse        [<template_file>]\n    precompressed <formats...>\n    status        <status>\n    disable_canonical_uris\n}\n\n```\nThe FinalizeUnmarshalCaddyfile method should be called after this\nto finalize setup of hidden Caddyfiles.",
	"filter": "```\nfilter {\n    wrap <another encoder>\n    fields {\n        <field> <filter> {\n            <filter options>\n        }\n    }\n    <field> <filter> {\n        <filter options>\n    }\n}\n```",
	"forward_auth": "```\nforward_auth auth-gateway:9091 {\n    uri /authenticate?redirect=https://auth.example.com\n    copy_headers Remote-User Remote-Email\n}\n\n```\nis equivalent to a reverse_proxy directive like this:\n\n```\nreverse_proxy auth-gateway:9091 {\n    method GET\n    rewrite /authenticate?redirect=https://auth.example.com\n\n    header_up X-Forwarded-Method {method}\n    header_up X-Forwarded-Uri {uri}\n\n    @good status 2xx\n    handle_response @good {\n        request_header {\n            Remote-User {http.reverse_proxy.header.Remote-User}\n            Remote-Email {http.reverse_proxy.header.Remote-Email}\n        }\n    }\n}\n```",
	"fs": "```\nfs <filesystem>\n```",
	"handle_path": "```\nhandle_path [<matcher>] {\n    <directives...>\n}\n\n```\nOnly path matchers (with a `/` prefix) are supported as this is a shortcut\nfor the handle directive with a strip_prefix rewrite.",
	"header": "```\nheader [<matcher>] [[+|-|?|>]<field> [<value|regexp>] [<replacement>]] {\n\t[+]<field> [<value|regexp> [<replacement>]]\n\t?<field> <default_value>\n\t-<field>\n\t><field>\n\t[defer]\n}\n\n```\nEither a block can be opened or a single header field can be configured\nin the first line, but not both in the same directive. Header operations\nare deferred to write-time if any headers are being deleted or if the\n'defer' subdirective is used. + appends a header value, - deletes a field,\n? conditionally sets a value only if the header field is not already set,\nand > sets a field with defer enabled.",
	"intercept": "```\nintercept [<matcher>] {\n    # intercept original responses\n    @name {\n        status <code...>\n        header <field> [<value>]\n    }\n    replace_status [<matcher>] <status_code>\n    handle_response [<matcher>] {\n        <directives...>\n    }\n}\n\n```\nThe FinalizeUnmarshalCaddyfile method should be called after this\nto finalize parsing of \"handle_response\" blocks, if possible.\n\nEXPERIMENTAL: Subject to change or removal.",
	"json": "```\njson {\n    <common encoder config subdirectives...>\n}\n\n```\nSee the godoc on the LogEncoderConfig type for the syntax of\nsubdirectives that are common to most/all encoders.",
	"lb_policy": "```\nlb_policy cookie [<name> [<secret>]] {\n\tfallback <policy>\n\tmax_age <duration>\n}\n\n```\nBy default name is `lb`",
	"local_ip": "```\nlocal_ip <ranges...>\n```",
	"log": "```\nlog <logger_name> {\n    hostnames <hostnames...>\n    output <writer_module> ...\n    core   <core_module> ...\n    format <encoder_module> ...\n    level  <level>\n}\n```",
	"log_append": "```\nlog_append [<matcher>] [<]<key> <value>\n```",
	"log_name": "```\nlog_name <names...>\n```",
	"log_skip": "```\nlog_skip [<matcher>]\n```",
	"map": "```\nmap [<matcher>] <source> <destinations...> {\n    [~]<input> <outputs...>\n    default    <defaults...>\n}\n\n```\nIf the input value is prefixed with a tilde (~), then the input will be parsed as a\nregular expression.\n\nThe Caddyfile adapter treats outputs that are a literal hyphen (-) as a null/nil\nvalue. This is useful if you want to fall back to default for that particular output.\n\nThe number of outputs for each mapping must not be more than the number of destinations.\nHowever, for convenience, there may be fewer outputs than destinations and any missing\noutputs will be filled in implicitly.",
	"message_key": "```\n{\n    message_key     <key>\n    level_key       <key>\n    time_key        <key>\n    name_key        <key>\n    caller_key      <key>\n    stacktrace_key  <key>\n    line_ending     <char>\n    time_format     <format>\n    time_local\n    duration_format <format>\n    level_format    <format>\n}\n```",
	"method": "```\nmethod [<matcher>] <method>\n```",
	"metrics": "```\nmetrics [<matcher>] {\n    disable_openmetrics\n}\n```",
	"multi_regexp": "```\nmulti_regexp {\n    regexp <pattern> <replacement>\n    regexp <pattern> <replacement>\n    ...\n}\n```",
	"net": "```\nnet <address> {\n    dial_timeout <duration>\n    soft_start\n}\n```",
	"php_fastcgi": "```\nphp_fastcgi localhost:7777\n\n```\nis equivalent to a route consisting of:\n\n```\n# Add trailing slash for directory requests\n# This redirection is automatically disabled if \"{http.request.uri.path}/index.php\"\n# doesn't appear in the try_files list\n@canonicalPath {\n    file {path}/index.php\n    not path */\n}\nredir @canonicalPath {path}/ 308\n\n# If the requested file does not exist, try index files and assume index.php always exists\n@indexFiles file {\n    try_files {path} {path}/index.php index.php\n    try_policy first_exist_fallback\n    split_path .php\n}\nrewrite @indexFiles {http.matchers.file.relative}\n\n# Proxy PHP files to the FastCGI responder\n@phpFiles path *.php\nreverse_proxy @phpFiles localhost:7777 {\n    transport fastcgi {\n        split .php\n    }\n}\n\n```\nThus, this directive produces multiple handlers, each with a different\nmatcher because multiple consecutive handlers are necessary to support\nthe common PHP use case. If this \"common\" config is not compatible\nwith a user's PHP requirements, they can use a manual approach based\non the example above to configure it precisely as they need.\n\nIf a matcher is specified by the user, for example:\n\n```\nphp_fastcgi /subpath localhost:7777\n\n```\nthen the resulting handlers are wrapped in a subroute that uses the\nuser's matcher as a prerequisite to enter the subroute. In other\nwords, the directive's matcher is necessary, but not sufficient.",
	"proxy_protocol": "```\nproxy_protocol {\n\ttimeout <duration>\n\tallow <IPs...>\n\tdeny <IPs...>\n\tfallback_policy <policy>\n}\n```",
	"push": "```\npush [<matcher>] [<resource>] {\n    [GET|HEAD] <resource>\n    headers {\n        [+]<field> [<value|regexp> [<replacement>]]\n        -<field>\n    }\n}\n\n```\nA single resource can be specified inline without opening a\nblock for the most common/simple case. Or, a block can be\nopened and multiple resources can be specified, one per\nline, optionally preceded by the method. The headers\nsubdirective can be used to customize the headers that\nare set on each (synthetic) push request, using the same\nsyntax as the 'header' directive for request headers.\nPlaceholders are accepted in resource and header field\nname and value and replacement tokens.",
	"redir": "```\nredir [<matcher>] <to> [<code>]\n\n```\n<code> can be \"permanent\" for 301, \"temporary\" for 302 (default),\na placeholder, or any number in the 3xx range or 401. The special\ncode \"html\" can be used to redirect only browser clients (will\nrespond with HTTP 200 and no Location header; redirect is performed\nwith JS and a meta tag).",
	"remote_ip": "```\nremote_ip <ranges...>\n\n```\nNote: IPs and CIDRs prefixed with ! symbol are treated as not_ranges",
	"request_header": "```\nrequest_header [<matcher>] [[+|-]<field> [<value|regexp>] [<replacement>]]\n```",
	"respond": "```\nrespond [<matcher>] <status>|<body> [<status>] {\n    body <text>\n    close\n}\n\n```\nIf there is just one argument (other than the matcher), it is considered\nto be a status code if it's a valid positive integer of 3 digits.",
	"reverse_proxy": "```\nreverse_proxy [<matcher>] [<upstreams...>] {\n    # backends\n    to      <upstreams...>\n    dynamic <name> [...]\n\n    # load balancing\n    lb_policy <name> [<options...>]\n    lb_retries <retries>\n    lb_try_duration <duration>\n    lb_try_interval <interval>\n    lb_retry_match <request-matcher>\n\n    # active health checking\n    health_uri          <uri>\n    health_port         <port>\n    health_interval     <interval>\n    health_passes       <num>\n    health_fails        <num>\n    health_timeout      <duration>\n    health_status       <status>\n    health_body         <regexp>\n    health_method       <value>\n    health_request_body <value>\n    health_follow_redirects\n    health_headers {\n        <field> [<values...>]\n    }\n\n    # passive health checking\n    fail_duration     <duration>\n    max_fails         <num>\n    unhealthy_status  <status>\n    unhealthy_latency <duration>\n    unhealthy_request_count <num>\n\n    # streaming\n    flush_interval     <duration>\n    request_buffers    <size>\n    response_buffers   <size>\n    stream_timeout     <duration>\n    stream_close_delay <duration>\n    verbose_logs\n\n    # request manipulation\n    trusted_proxies [private_ranges] <ranges...>\n    header_up   [+|-]<field> [<value|regexp> [<replacement>]]\n    header_down [+|-]<field> [<value|regexp> [<replacement>]]\n    method <method>\n    rewrite <to>\n\n    # round trip\n    transport <name> {\n        ...\n    }\n\n    # optionally intercept responses from upstream\n    @name {\n        status <code...>\n        header <field> [<value>]\n    }\n    replace_status [<matcher>] <status_code>\n    handle_response [<matcher>] {\n        <directives...>\n\n        # special directives only available in handle_response\n        copy_response [<matcher>] [<status>] {\n            status <status>\n        }\n        copy_response_headers [<matcher>] {\n            include <fields...>\n            exclude <fields...>\n        }\n    }\n}\n\n```\nProxy upstream addresses should be network dial addresses such\nas `host:port`, or a URL such as `scheme://host:port`. Scheme\nand port may be inferred from other parts of the address/URL; if\neither are missing, defaults to HTTP.\n\nThe FinalizeUnmarshalCaddyfile method should be called after this\nto finalize parsing of \"handle_response\" blocks, if possible.",
	"rewrite": "```\nrewrite [<matcher>] <to>\n\n```\nOnly URI components which are given in <to> will be set in the resulting URI.\nSee the docs for the rewrite handler for more information.",
	"root": "```\nroot [<matcher>] <path>\n```",
	"skip_log": "```\nlog_skip [<matcher>]\n```",
	"sni": "```\nsni <domains...>\n```",
	"templates": "```\ntemplates [<matcher>] {\n    mime <types...>\n    between <open_delim> <close_delim>\n    root <path>\n}\n```",
	"tls": "```\ntls [<email>|internal|force_automate]|[<cert_file> <key_file>] {\n    protocols <min> [<max>]\n    ciphers   <cipher_suites...>\n    curves    <curves...>\n    client_auth {\n        mode                   [request|require|verify_if_given|require_and_verify]\n        trust_pool             <module_name> [...]\n        trusted_leaf_cert      <base64_der>\n        trusted_leaf_cert_file <filename>\n    }\n    alpn                          <values...>\n    load                          <paths...>\n    ca                            <acme_ca_endpoint>\n    ca_root                       <pem_file>\n    key_type                      [ed25519|p256|p384|rsa2048|rsa4096]\n    dns                           [<provider_name> [...]]    (required, though, if DNS is not configured as global option)\n    propagation_delay             <duration>\n    propagation_timeout           <duration>\n    resolvers                     <dns_servers...>\n    dns_ttl                       <duration>\n    dns_challenge_override_domain <domain>\n    on_demand\n    reuse_private_keys\n    force_automate\n    eab                           <key_id> <mac_key>\n    issuer                        <module_name> [...]\n    get_certificate               <module_name> [...]\n    insecure_secrets_log          <log_file>\n    renewal_window_ratio          <ratio>\n}\n```",
	"tracing": "```\ntracing {\n    [span <span_name>]\n\t[span_attributes {\n\t\tattr1 value1\n\t\tattr2 value2\n\t}]\n}\n```",
	"transport": "```\ntransport http {\n    read_buffer             <size>\n    write_buffer            <size>\n    max_response_header     <size>\n    network_proxy           <module> {\n        ...\n    }\n    dial_timeout            <duration>\n    dial_fallback_delay     <duration>\n    response_header_timeout <duration>\n    expect_continue_timeout <duration>\n    resolvers               <resolvers...>\n    tls\n    tls_client_auth <automate_name> | <cert_file> <key_file>\n    tls_insecure_skip_verify\n    tls_timeout <duration>\n    tls_trusted_ca_certs <cert_files...>\n    tls_trust_pool <module> {\n        ...\n    }\n    tls_server_name <sni>\n    tls_renegotiation <level>\n    tls_except_ports <ports...>\n    keepalive [off|<duration>]\n    keepalive_interval <interval>\n    keepalive_idle_conns <max_count>\n    keepalive_idle_conns_per_host <count>\n    versions <versions...>\n    compression off\n    max_conns_per_host <count>\n    max_idle_conns_per_host <count>\n}\n```",
	"trust_pool": "```\ntrust_pool inline {\n\ttrust_der <base64_der_cert>...\n}\n\n```\nThe 'trust_der' directive can be specified multiple times.",
	"try_files": "```\ntry_files <files...> {\n\tpolicy first_exist|smallest_size|largest_size|most_recently_modified\n}\n\n```\nand is basically shorthand for:\n\n```\n@try_files file {\n\ttry_files <files...>\n\tpolicy first_exist|smallest_size|largest_size|most_recently_modified\n}\nrewrite @try_files {http.matchers.file.relative}\n\n```\nThis directive rewrites request paths only, preserving any other part\nof the URI, unless the part is explicitly given in the file list. For\nexample, if any of the files in the list have a query string:\n\n```\ntry_files {path} index.php?{query}&p={path}\n\n```\nthen the query string will not be treated as part of the file name; and\nif that file matches, the given query string will replace any query string\nthat already exists on the request URI.",
	"uri": "```\nuri [<matcher>] strip_prefix|strip_suffix|replace|path_regexp <target> [<replacement> [<limit>]]\n\n```\nIf strip_prefix or strip_suffix are used, then <target> will be stripped\nonly if it is the beginning or the end, respectively, of the URI path. If\nreplace is used, then <target> will be replaced with <replacement> across\nthe whole URI, up to <limit> times (or unlimited if unspecified). If\npath_regexp is used, then regular expression replacements will be performed\non the path portion of the URI (and a limit cannot be set).",
	"validity_days": "```\n... zerossl <api_key> {\n\t    validity_days <days>\n\t    alt_http_port <port>\n\t    dns <provider_name> ...\n\t    propagation_delay <duration>\n\t    propagation_timeout <duration>\n\t    resolvers <list...>\n\t    dns_ttl <duration>\n}\n```",
	"vars": "```\nvars [<name> <val>] {\n    <name> <val>\n    ...\n}\n```",
}
